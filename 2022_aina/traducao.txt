Resumo
In-band Network Telemetry (INT) é uma abordagem de monitoramento de rede promissora que permite uma visibilidade de rede ampla e refinada. No entanto, quando um grande volume de dados de telemetria é relatado a um coletor INT, pode sobrecarregar toda a infraestrutura da rede, embora ainda prejudique o desempenho do processamento de pacotes no nó coletor INT. Conforme relatado anteriormente na literatura, dispositivos programáveis - em particular, SmartNICs - têm restrições estritas em termos de processamento e memória. Neste trabalho, propomos projetar e implementar um mecanismo leve baseado em média móvel exponencialmente ponderada dentro do plano de dados SmartNIC para auxiliar no processo de tomada de decisão de relatar dados INT. Ao avaliar nossa solução em SmartNICs de última geração, mostramos que nossa proposta pode diminuir o número de dados de telemetria não essenciais enviados para coletores INT em até 16X em comparação com a abordagem INT de fato, apresentando menor sobrecarga em termos de latência do pacote.

1. Introdução
A telemetria de rede in-band é uma abordagem promissora de monitoramento de rede quase em tempo real [12, 17, 21] que permite uma visibilidade ampla e refinada da rede. Resumindo, o INT consiste em instrumentar a coleção de estatísticas de monitoramento de rede de baixo nível diretamente do plano de dados - permitindo que operadores de rede / aplicativos de monitoramento sejam alimentados com um nível de informação sem precedentes. Exemplos de tais estatísticas na rede incluem metadados de plano de dados (por exemplo, tempo de processamento por pacote ou utilização de fila) e / ou feitos sob medida (por exemplo, intervalo entre pacotes de fluxo de rede [23]). Nos últimos anos, a INT tem sido aplicada com sucesso a uma série de casos de uso, incluindo a identificação de comportamentos de rede de curta duração [13] e anomalias de rede [11].
Na especificação INT salto a salto clássico (ou seja, INT-MD (eMbed Data) 1), um nó de origem INT incorpora instruções em pacotes de rede de produção normalmente usando campos de cabeçalho não utilizados (por exemplo, opções IPv4) ou reencapsulando a rede tráfego (por exemplo, usando encapsulamento INT). Em seguida, os nós de trânsito INT incorporam metadados a esses pacotes de acordo com as instruções fornecidas pela fonte INT. Por último, um nó coletor INT retira a instrução do pacote e envia os dados de telemetria acumulados para um coletor INT. A Figura 1 ilustra todo o procedimento INT. Neste exemplo, um pacote do fluxo de rede f 1 é usado para coletar dados INT dos dispositivos de encaminhamento A a F. Recentemente, as investigações fizeram os primeiros esforços para orquestrar de forma eficiente como os metadados INT são coletados por pacotes de rede [21, 2, 11, 5], a fim de aumentar a visibilidade da rede e detectar eventos de rede em tempo hábil. Isso inclui, por exemplo, selecionar os fluxos / pacotes de rede apropriados para coletar os metadados de telemetria de rede certos na infraestrutura de rede. Este problema provou ser NP-difícil, uma vez que os pacotes podem ter diferentes capacidades sobressalentes (por exemplo, limitado pelo link de dados MTU) [18].
Apesar desses esforços, pouco ainda foi feito para relatar com eficiência e sabedoria os dados de telemetria coletados para um coletor INT [22]. No caso em que todos os dados de telemetria são relatados a um coletor INT, isso pode levar a (i) um uso excessivo de links de rede entre o coletor INT e o coletor INT. Por exemplo, se considerarmos um link de rede de 10 Gbit / s enviando pacotes de 64Bytes (ou seja, 14,88 Mpps) e coletando 1 Byte por trânsito de nó INT ao longo do caminho, o volume de tráfego de rede necessário a ser relatado por segundo seria de 118 Mbit ∗ saltos (comprimento do caminho). Na verdade, esse volume de dados relatados pode aumentar substancialmente se assumirmos a arquitetura de referência canônica para dispositivos programáveis 2, em que cada dispositivo tem pelo menos 30 bytes de metadados; (ii) degradação do desempenho nas capacidades de processamento de pacotes no coletor INT devido ao uso de primitivas de clonagem / recirculação de pacotes dentro do plano de dados. Para enviar o pacote de rede ao coletor INT (ou parte dele), os dispositivos programáveis precisam contar com primitivas de recirculação / clonagem de pacotes para duplicar o pacote - o que reduz drasticamente o desempenho em termos de throughput e latência [26]; e (iii) sobrecarregar o aplicativo coletor INT com pacotes de dados INT.
Para preencher esta lacuna, neste trabalho propomos um mecanismo de relatório INT seletivo totalmente implementado usando um SmartNIC. Conforme relatado anteriormente por [26], os dispositivos programáveis têm restrições rigorosas em termos de capacidades de processamento (por exemplo, falta de operações de ponto flutuante) e limitações de uso de memória. Assumimos que o nó coletor INT está no topo de um SmartNIC e, portanto, a decisão se relatar dados de telemetria ou não está no NIC. Nosso mecanismo proposto utiliza uma média móvel exponencialmente ponderada leve dentro do plano de dados. Para isso, o implementamos usando a linguagem P4 e rotinas Micro-C para permitir operações mais complexas dentro do plano de dados. Ao realizar uma extensa avaliação de desempenho usando SmartNICs, mostramos que nossa abordagem proposta pode reduzir a quantidade de dados de telemetria não importantes enviados para o coletor INT em até 16X (em comparação com o INT clássico), enquanto introduz uma sobrecarga insignificante em termos de pacote latência.
As principais contribuições deste artigo podem ser resumidas como:
um mecanismo na rede implementado em SmartNICs de última geração para decidir sabiamente quando relatar metadados INT;
uma discussão das limitações atuais na implementação de computação em rede em arquiteturas SmartNIC; e
um código-fonte aberto para promover a reprodutibilidade.
O restante deste artigo está organizado da seguinte forma. Na Seção 2, descrevemos a arquitetura SmartNIC usada neste trabalho. Na Seção 3, apresentamos nossa abordagem proposta. Na Seção 4, discutimos os resultados obtidos. Na Seção 5, apresentamos uma visão geral da literatura recente sobre telemetria de rede em banda e. Por fim, na Seção 6, concluímos este artigo com as considerações finais.

2. Antecedentes
NICs programáveis de última geração (denominados SmartNICs) contam com suas arquiteturas em (i) unidades de processador de fluxo multi-threaded e multi-core ou (ii) em FPGAs (Field Programmable Gate Arrays) para atender à crescente e rígida demanda. Concentramos nossa análise nos elementos arquitetônicos gerais da arquitetura Netronome SmartNIC [20] - que é usada posteriormente em nossos experimentos de desempenho - e contamos com uma arquitetura multi-core.
A arquitetura SmartNIC Netronome NFP4000 gerencia seus núcleos de processamento de fluxo (FPC) em várias ilhas (Figura 2). Cada FPC inclui oito Micro Engines (MEs) como um processador particular, mantendo seu próprio armazenamento de instruções (código) e memória local (dados). Portanto, cada ME na arquitetura pode executar código com todos os outros MEs em paralelo. Para dar suporte a esse recurso, cada ME possui 8 threads que podem ser usados para multithreading cooperativo de forma que, em um determinado momento, no máximo, uma thread esteja executando código do mesmo programa. Isso significa que cada FPC lida com no máximo oito threads paralelas a 1,2 Ghz (uma thread por ME). Em cada FPC, a memória local compreende registros de 32 bits, compartilhados entre todos os oito threads. Esses registros são separados em: (i) registros de uso geral (256 registros de 32 bits) - usados por padrão para armazenar qualquer registro de até 32 bits; (ii) registros de transferência (512 registros de 32 bits) - usados para copiar o registro no barramento de interconexão (por exemplo, de ou para outros FPCs ou memórias); (iii) registradores do próximo vizinho (128 registradores de 32 bits) - usados principalmente para intercomunicação com FPCs adjacentes; e (iv) memória local (1024 registros de 32 bits) - que é um pouco mais lenta do que o registro geral. Quando há uma demanda por mais memória do que o espaço disponível nos registros FPC locais, as variáveis são automaticamente e estaticamente atribuídas a outras hierarquias de memória no chip. Além disso, existem outros tipos de memória disponíveis para FPCs: (i) Cluster Local Scratch (CLS) (20-50 ciclos); (ii) Memória de destino de cluster (CTM) (50-100 ciclos); (iii) Memória Interna (IMEM) (120-250 ciclos); e (iv) Memória Externa (EMEM) (150-590 ciclos). Para mais detalhes, o leitor interessado pode consultar [20].
Conforme os pacotes são adquiridos da rede, um thread FPC pega os pacotes e os processa. Threads extras são atribuídos a novos pacotes conforme eles chegam. Por exemplo, o SmartNIC NFP-4000 suporta até 60 FPCs, o que permite o processo de até 480 pacotes simultaneamente. O SmartNIC permite programá-lo diretamente usando a linguagem Micro-C (ou seja, um subconjunto da linguagem C) ou usando linguagens de domínio específico de alto nível, como P4 [3]. O código é então compilado e atribuído estaticamente a um subconjunto específico de FPC.

3 ETA: Abordagem inicial do analisador de fluxo de telemetria de rede
Nesta seção, primeiro definimos o modelo usado por nossa abordagem proposta para decidir se os dados de telemetria da rede são ou não enviados para um coletor INT. Em seguida, descrevemos como ele é implementado em um SmartNIC e discutimos as limitações e desafios existentes.

3.1 Definição de Modelo e Problema
Consideramos que um dispositivo de encaminhamento programável d ∈ D tem N ∈ N + metadados disponíveis para serem coletados por um pacote habilitado para INT p e que esse pacote tem uma capacidade limitada disponível para transportar até M ∈ N + de tais N itens (M ≥ N). Para simplificar, presumimos que todos os dispositivos D têm as mesmas informações de telemetria e que um pacote p habilitado para INT só pode coletar dados de telemetria atomicamente, ou seja, ele coleta todos os metadados N de d ∈ D ou nenhum deles. O pacote p pode coletar apenas uma vez o mesmo subconjunto de dados de telemetria do dispositivo d. Assumimos que a fonte INT instrui o pacote p corretamente de acordo com um determinado algoritmo (por exemplo, [18]).
Considere que um pacote p coletou dados de telemetria M ′ ⊆ M ao longo de seu caminho de roteamento - que compreende um subconjunto de dispositivos D. Quando o pacote p chega ao nó coletor INT, a questão a ser respondida é: deve ser enviado para o coletor INT ou não? Para responder a esta questão, o nó coletor INT calcula (i) uma média ponderada dos metadados M ′ coletados pelo pacote pe (ii) uma média móvel exponencial ponderada. O primeiro tende a pesar os dados de telemetria coletados de forma diferente de acordo com sua importância. Por exemplo, os metadados de tempo de processamento (ou utilização da fila) podem ser mais importantes a serem considerados no processo de decisão do que o tamanho do pacote. Por sua vez, o último tende a manter na memória o comportamento observado das últimas informações de telemetria recebidas ao longo do tempo.
Após um pacote p recebido no nó coletor INT, ele extrai os M ′ metadados de telemetria coletados e calcula uma média ponderada por pacote PM ′ A p = 1] é o i-ésimo peso dado a i = 1 wi · M i (Eq . 1), onde wi ∈ [0, PM os dados de telemetria. Além disso, assumimos que i = 1 w i = 1 e que M i corresponde aos i-ésimos dados coletados. Essas médias individuais A p são então somadas em uma métrica média ponderada acumulada dentro de uma determinada janela de tempo W (discutiremos essa escolha de projeto a seguir). A janela de tempo W é definida para simplicidade como um número predefinido de pacotes. No entanto, ele pode ser estendido para outras métricas, como um intervalo de tempo.
Então, a média ponderada acumulada de uma determinada janela W é dada por P W A p A w = p = 1 (Eq. 2). Da mesma forma, a média móvel exponencial ponderada W é obtida por A e = α · A w + (1 - α) · A e (Eq. 3) onde α ∈ [0, 1] compreende a importância dada pelos elementos obtidos no última janela W versus o conhecimento histórico mantido pela média móvel A e. Observe que valores mais altos atribuídos a α priorizam o comportamento na janela mais recente, enquanto valores mais baixos priorizam o comportamento observado ao longo do tempo. O processo de tomada de decisão é feito por pacote; no entanto, as métricas de tomada de decisão (por exemplo, A e) são atualizadas em uma janela de tempo.

3.2 Projeto e implementação em um SmartNIC
A Figura 3 ilustra uma visão geral da implementação do pipeline de abordagem proposta. Nossa abordagem utiliza a arquitetura V1Model de referência para dispositivos de encaminhamento programáveis como base para implementar / adicionar tais funcionalidades ao Netronome SmartNIC. Além disso, nossa abordagem é baseada em P4-16 e em linguagens Micro-C.
Quando um pacote é recebido pelo SmartNIC, o pacote é analisado adequadamente. Nossa implementação de abordagem reside logo após a etapa de análise e o pipeline de entrada (onde ocorre a decisão de roteamento), ou seja, no pipeline de saída. Para esta discussão, presumimos que nosso dispositivo de encaminhamento pode processar quadros Ethernet e pacotes IP (ou qualquer protocolo de encapsulamento INT conhecido). Portanto, omitimos as etapas de análise, uma vez que é trivial e está fora do escopo deste trabalho. Em seguida, nos concentramos nas etapas seguintes.
Nossa abordagem é implementada no coletor INT. Portanto, nesta fase, todos os metadados de telemetria INT já foram coletados. As primeiras etapas de nossa abordagem consistem em receber o pacote e extrair os dados de telemetria dele - ou, em alguns casos, coletá-los diretamente do plano de dados (isso pode acontecer quando o nó coletor INT atua como um nó de trânsito INT também) . Isso corresponde às etapas 1 e 2 na Figura 3. Os dados extraídos são então armazenados em uma estrutura de cabeçalho de metadados customizada - denominada estrutura de metadados ETA. Esta estrutura compreende estruturas M de 32 bits e um sinalizador de 2 bits usado para instruir o processo de tomada de decisão. Por exemplo, se um pacote precisa ser enviado ao coletor INT, este sinalizador é usado internamente. Na arquitetura do Netronome, os carimbos de data / hora existentes (carimbo de data / hora de ingresso e carimbo de data / hora atual) são palavras de 48 bits. No entanto, a maioria dos aplicativos usa apenas os bits menos significativos (os últimos 32 bits), pois eles são responsáveis pelas diferenças de nanossegundos. Além disso, como discutido a seguir, a arquitetura do Netronome também limita os resultados das operações aritméticas a palavras de 32 bits (e, portanto, não podemos operar em carimbos de data / hora de 48 bits). Depois de extrair os dados de telemetria na estrutura ETA, nossa implementação chama um código externo Micro-C para lidar com operações mais complexas dentro do plano de dados (representado na Figura 4). Por exemplo, as operações de ponto flutuante não são permitidas na referência de linguagem P4-16, nem o SmartNIC as implementa nativamente. Para permitir que o código SmartNIC seja parcialmente escrito em P4 e Micro-C - e mais importante, para trocar dados entre eles - contamos com estruturas ETA e metadados P4 internos para permitir tais comunicações em tempo real.
O código Micro-C começa a receber dados do pipeline P4 e bloquear regiões de memória usando um mutex (etapas 1-3 na Figue 4). Isso é necessário, pois nosso aplicativo compartilha regiões de memória entre processadores / threads para armazenar a janela atual W ′, bem como os valores atuais das médias calculadas (ou seja, A e e A w). Em seguida, calculamos A p e A w de acordo com a Equação 1 e a Equação 2, respectivamente. A Figura 4 ilustra esses procedimentos nas etapas 4-7. É importante mencionar que nem a arquitetura de referência P4 nem o Netronome suportam instruções de ponto flutuante. Implementamos todas essas operações usando representação de ponto fixo com 32 bits para superar essa limitação. Resumindo, uma representação de ponto fixo trata todos os números reais como inteiros. O processo aumenta a escala dos números multiplicando por um fator constante C e, em seguida, realiza as multiplicações / divisão como um número inteiro regular. Finalmente, o resultado ampliado é reduzido apropriadamente. Em nossa implementação, usamos uma constante C de 16 bits e executamos a operação de aumento de escala aplicando uma operação de deslocamento de bits (ou seja, M i ′ << 16). Após o cálculo de A p, verificamos se é o caso de enviá-lo para o coletor do INT. Comparamos A p com o A e observado (que captura o comportamento histórico). Caso o valor do pacote A p seja maior que o A e dinâmico, marcamos o pacote a ser enviado ao coletor (etapas 8-12 na Figura 4).
Conforme mencionado anteriormente, nossa abordagem executa decisões por pacote. No entanto, atualizamos a média móvel exponencial ponderada A e no final de uma determinada janela W. Isso é feito porque o A e médio depende de A w - e a arquitetura do Netronome não permite divisões inteiras arbitrárias (apenas pela potência de 2 realizando deslocamento de bits - por exemplo, M i ′ >> 16). Nossa abordagem verifica se ele atinge ou não o final de uma determinada janela W (etapa 14 na Figura 4). Se assim for, então ele atualiza a média móvel A e (etapa 15-19 na Figura 4) de acordo com a Equação 3. Além disso, se for a primeira vez para alcançar a janela W (ou seja, W ′ == W), então A e assume uma média simples de A w (etapa 20 na Figura 4). Em seguida, o Micro-C desativa o mutex e permite que outros threads usem a memória compartilhada bloqueada. Por último, nosso código Micro-C retorna os valores calculados para o pipeline P4 original (etapa 22-23 na Figura 4).
De volta ao pipeline P4 (Figura 3), nossa abordagem clona e recircula o pacote p. O pacote original é encaminhado ao seu destino (etapa 13 da Figura 3), enquanto o pacote clonado é enviado ao coletor INT (etapa 12 da Figura 3).